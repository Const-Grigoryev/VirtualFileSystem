Virtual File System
===================

Данная библиотека предназначена для эмуляции работы файловой системы. Она позволяет хранить несколько файлов в одном,
подобно тому, как это делают программы-архиваторы (но без сжатия). Этот файл-хранилище будет в дальнейшем именоваться
_архивом_, а содержащиеся в нем файлы _виртуальными_. Текущая реализация позволяет иметь до `2^31 - 1` виртуальных
файлов в одном архиве, каждый размером до `2^31 - 1` байт. Кроме того, существует ограничение на общий размер архива:
`2^32 - 1` блоков (см. ниже), т.е. приблизительно 2 ТБ при блоке стандартного размера.

В отличие от реальных файловых систем, ориентированных на работу в фиксированном дисковом пространстве, архив растёт
динамически по мере необходимости.

Система разрабатывалась так, чтобы минимизировать количество дисковых операций, в частности, исключить перемещение
данных. Ценой этого стала высокая степень фрагментации данных (это приемлемо, т.к. современные SSD обладают хорошей
скоростью произвольного доступа).

Файловая система "плоская", т.е. не поддерживает какой-либо иерархии подкатологов (и вообще понятия каталога
как такового). Это не принципиальное ограничение, оно сделано исключительно ради простоты реализации.


Структура архивного файла
-------------------------

Архивный файл состоит из блоков фиксированного размера. Размер блока задается при создании архива и не может быть
изменён в дальнейшем. Размер блока по умолчанию составляет 512 байт.

Блоки идентифицируются по _номерам_. Фиксированный размер позволяет с легкостью определить расположение блока  в файле:
блок номер `k` имеет смещение `k * blockSize`.

Каждый блок принадлежит одному из следующих типов:

  * **Блок данных** — содержит часть двоичных данных одного из виртуальных файлов. Помимо этого, этот блок содержит
    ссылку на следующий блок данных того же файла; таким образом, блоки данных одного файла соединяются в цепочку
    (односвязный список).
    
  * **Индексный блок** — содержит метаинформацию об одном из виртуальных файлов (а именно, его размер и имя), а также
    ссылки на первый и последний блок данных этого файла. Совокупность всех индексных блоков архива образует двухсвязный
    список.
    
  * **Свободный блок**. Остаются после удаления виртуального файла. По формату свободные блоки похожи на блоки данных,
    она также связаны в цепочку.
    
  * **Заголовочный блок**. В этом блоке хранятся ссылки на начало и конец списка индексных блоков, ссылка на начало
    цепочки свободных блоков, а также общая информация об архиве (самое главное, размер блока архива). В архиве
    существует ровно один блок данного типа, он имеет номер 0, т.е. расположен в самом начале архивного файла.

На низком уровне, каждый блок состоит из заголовка и тела; в заголовке записана сигнатура, задающая тип блока, и
контрольная сумма. Контрольная сумма подсчитывается для тела блока с помощью алгоритма CRC32.

Сигнатура — это 4 байта, определяющие тип блока, т.е. интерпретацию его тела:

  * Сигнатура **DTA1** обозначает заголовочный блок (и одновременно заголовок всего архива). Сигнатуры **DTA2**,
    **DTA3** и т.д. зарезервированы для будущих версий.
    
  * Сигнатура **DTFI** обозначает индексный блок.

  * Сигнатура **DTFD** — блок данных или свободный блок.


Операций с файлами
------------------

### Построение оглавления

Оглавление — это таблица (`HashMap`), соотносящая имя виртуального файла с номером его индексного блока. Для её
построения необходимо обойти список индексных блоков, что занимает время `O(N)`, но это требуется сделать только один
раз при загрузке архива. Поддержание оглавления в актуальном состоянии стоит `O(1)` за каждую операцию.

### Создание нового файла

При создании нового (пустого) файла производится следующая последовательность действий:

  1. От начала цепочки свободных блоков отсоединяется один блок (`O(1)`). Если цепочка свободных блоков пуста, новый
     блок создается в конце архива.
     
  2. Этот блок назначается индексным для данного виртуального файла, в него заносится вся метаинформация (имя файла
     указывается пользователем при создании, длина файла изначально равна 0, ссылки на первый и последний блок данных
     также равны 0).
     
  3. Блок добавляется в конец списка индексных блоков (`O(1)`).

  4. Запись о файле добавляется в оглавление, хранящееся в основной памяти (`O(1)`).

### Удаление файла

  1. Номер индексного блока файла определяется при помощи оглавления (`O(1)`).

  2. Индексный блок удаляется из списка индексных блоков (`O(1)` благодаря тому, что список двухсвязный).

  3. Удаленный блок добавляется в цепочку свободных блоков (`O(1)`).

  4. Цепочка блоков данных удаленного файла присоединяется к цепочке свободных блоков. Так как свободные блоки
     идентичны по структуре блокам данных, соединение цепочек производится за время `O(1)`.
     
  5. Из оглавления удаляется запись о файле (`O(1)`).

### Чтение файла

Данная виртуальная файловая система допускает только последовательный доступ к данным файла. Файл загружается
в память целиком, в виде массива.

  1. Сначала идентифицируется индексный блок файла.

  2. Выделяется массив, согласно записи о размере файла в индексном блоке.
     
  3. Индексный блок содержит ссылку на первый блок данных, тот — на следующий, и т.д. Данные из блоков последовательно
     копируются в массив.
     
  4. Массив возвращается пользователю.

### Запись файла

  1. Определяется индексный блок файла, при необходимости этот блок создается (см. "Создание нового файла")

  2. Предыдущие данные файла (если они есть) удаляются.

  3. Рассчитывается количество блоков, необходимое для хранения содержимого файла.
     
  4. Блоки данных выделяются из списка свободных блоков, при его исчерпании — создаются в конце архива.

  5. Блоки данных последовательно заполняются данными и соединяются в цепочку.

  6. Обновляется метаинформация в индексном блоке и оглавлении.


Архитектура программного решения
--------------------------------

Библиотека состоит из нескольких слоев, каждый из которых решает свою отдельную задачу.

Самый нижний слой, слой хранилища (**Storage**), умеет считывать и записывать блоки, но ничего не знает о связях между
ними.

**Backend** осуществляет манипуляции с блоками, поддерживая структуру архива. Именно здесь реализованы файловые
операции, перечисленные выше.

**Frontend** предоставляет более дружественный интерфейс (например, идентификацию файлов по именам, а не номерам
индексных блоков), а также решает задачи синхронизации доступа из нескольких потоков. Интерфейс frontend-а вдохновлен
стандартными пакетами `java.nio.file` и `java.nio.channels`, но не придерживается строго их спецификации.
